---
title: Spring06_복습
toc: true
toc_sticky: true
toc_label: "Contents of Page"
categories:
  - Study
tags:
  - Spring_Study
---

<br><br>

* 이 게시물은 `처음 시작하는 스프링 프레임워크 - 허진경 지음` 책을 공부하며 작성한 글입니다.
  - <span style="color:lightgray">교수님! 좋은 책 주셔서 감사합니다:)</span>

# 1. DI 
## 1-1. DI
* DI를 사용하지 않는 코드는 직접 필요한 객체를 생성해서 사용해야했다.
 - HelloController.java : `IHelloService helloService = new HelloService();`
 - HelloController는 인터페이스를 이용해 기능을 사용하고 싶어도 HelloService클래스가 없다면 사용 불가. (강한 의존관계)
 - 강한 의존관계를 이루지 않도록 HelloService 클래스가 완성된 후 객체를 생성하여 HelloController클래스에게 줄 수 있음

* DI를 사용한 코드
  - `생성자 주입` : HelloController.java
    1. `IHelloService helloService;`를 멤버객체로 선언 후
    2. 생성자 주입 : `public HelloController(IHelloService helloservice){ this.helloService = helloservice; }`
    3. main에서 객체 생성시 생성자 주입
  - `Setter주입` : HelloController.java
    1. `IHelloService helloService;`를 멤버객체로 선언 후
    2. Setter주입 : `public void setHelloService(IHelloService helloservice){ this.helloService = helloservice; }`
    3. main에서 기본 생성자로 Controller객체 선언 후, .setHelloService(helloservice); 객체 전달

<br><br><br>

## 1-2. Spring DI
* 스프링의 의존성 주입?
  - 스프링 컨테이너
  - 스프링은 필요로하는 bean을 생성하여 컨테이너에서 관리한다.
  - 이때 bean을 생성하기 위한 설정과 의존객체를 주입시키기 위한 설정이 필요하다.
* 종류
  - XML을 이용한 DI
  - Annotation을 이용한 DI 

<br><br>

### 1-2-1. XML 이용한 DI
* 생성자를 이용한 의존성 주입
* setter 메소드를 이용한 의존성 주입

#### 00. 시작 전, 설정하기
* `src/main/resources`에서 Spring Bean Configuration File 생성 ( = xml 파일생성)
* bean설정
  - name / id : 고유 식별자 지정.
  - class : 필수속성, Bean작성하는데 사용할 클래스. `패키지이름.클래스이름`
  - scope : 객체 범위 (prototype(요청할때마다 새로운객체 생성), singleton(bean이 항상 하나만 생성), request, session (WebApplicationContext사용시 적용))
  - lazy-init : bean이 사용되는 시점에 인스턴스 생성 (true / false)
  - destroy-method : bean삭제 직전 지정한 메소드 실행

* `<import>`태그
  - import 태그를 이용하여 여러 설정 파일을 포함시킬 수 있음 ( 여러 파일을 한곳에 쓴것과 같은 기능 )

```xml
<import resource="context-common1.xml" />
<import resource="context-common2.xml" />
```

#### 01. Spring Context
  - 객체를 생성하고 관리하는 컨테이너 기능
  - BeanFactory 인터페이스를 구현한 클래스
    + Lazy Loading방식 : 클라이언트 요청시 bean생성
    + 설정파일에 등록된 bean을 생성하고 관리하는 기본적인 컨테이너 기능만 제공
  - ApplicationContext 인터페이스를 구현한 클래스
    + Pre Loading방식
    + bean을 생성하고 관리하는 기능 외에 트랜잭션 관리, 국제화 처리 등 많은 기능 제공. 
    + FileSystemXmlApplicationContext : 파일 시스템 경로의 xml설정 파일을 로딩
    + ClassPathXmlApplicationContext : 클래스 패스 경로에 있는 xml설정 파일 로딩
    + GenericXmlApplicationContext : 파일 시스템 경로의 xml, 클래스 패스 경로의 xml 파일 로딩 (클래스패스 경로 시 `classpath:` 접두어 붙인다.)
    + XmlWebApplicationContext : 웹 애플리케이션 개발에 사용되지만 직접 생성하지 않는 Context

```java
ApplicationContext context = new GenericXmlApplicationContext("application-config.xml");
context.close();
```

<br><br>

#### 02. 생성자 주입
* Controller 클래스에 IHelloService helloService; 인터페이스 객체 멤버변수 선언후 이에 객체를 주입하는 생성자 추가.
* 스프링 설정 파일에 `<constructor-arg>`태그로 의존성 주입
  - ref속성으로 의존성 주입할 다른 bean 아이디 지정 
  - <constructor-arg ref="helloService"/>

```xml
<bean id="helloService" class="패키지명.HelloService(클래스명)"/>
<bean id="helloController" class="패키지명.HelloController">
   <constructor-arg ref="helloService"/>
</bean>
```

<br>

* 생성자의 인자로 전달하는 인자의 type이 문자열이거나 기본 데이터 타입일 경우 value속성 이용

```xml
<constructor-arg value="oracle.jdbc.driver.OracleDriver" />
<constructor-arg value="jdbc:oracle:thin:@localhost:1521:xe" />
```

<br>

* index속성 지정도 가능.

```xml
<constructor-arg index="1" value="oracle.jdbc.driver.OracleDriver" />
<constructor-arg index="0" value="jdbc:oracle:thin:@localhost:1521:xe" />
```

<br>

* 인자로 전달하는 객체가 null일 경우 

```xml
<constructor-arg>
  <null/>
</constructor-arg>
```

<br><br>

#### 03. Setter메소드 주입
* Controller 클래스에 IHelloService helloService; 인터페이스 객체 멤버변수 선언후 이에 객체를 주입하는 Setter 메소드 추가.
* 스프링 설정파일에서 `<property>`태그를 이용하여 의존 객체 주입 <span style="color:red">( 기본 생성자 외에 다른 생성자 정의 금지 )</span>
  - name : 의존성을 주입할 bean의 고유 이름
  - ref : 의존성을 주입할 객체의 이름
  - value : 값을 지정

```xml
<bean id="helloService" class="패키지명.HelloService"/>
<bean id="helloController" class="패키지명.HelloController">
    <property name="helloService" ref="helloService" />
</bean>
```

<br>

* value로 string,기본데이터 타입 의존성 주입 가능

```xml
<bean id="helloController" class="패키지명.HelloController">
  <property name="driverClassName" value="oracle.jdbc.driver.OracleDriver" />
  <property name="url" value="jdbc:oracle:thin:@localhost:1521:xe" />
</bean>
```

<br>

* p네임스페이스
  - Setter주입 사용시 p네임스페이스를 이용하여 bean 태그의 속성으로 의존성 주입 가능.
  - Namespace탭에서 `p 네임스페이스` 선택. 별도의 스키마가 없으므로, 네임스페이스만 선언하고 사용할 수 있다.
  - 의존성 주입
    + `p:변수명-ref="bean이름"`
  - string과 기본 데이터 타입
    + `p:변수명="값"`
* NameSpace탭 생기게 하기
  - 난 일단 안쓰는 중.
  - 일반 xml 파일로 만들면 안뜨는 것같다.
  - Spring Config File 의 xml만 사용가능
  - [설치참고블로그](https://m.blog.naver.com/CommentList.naver?blogId=sulin00&logNo=221963921025)


```xml
<bean id="helloService" class="패키지명.HelloService" />
<bean id="helloController" p:helloService-ref="helloService" class="패키지명.HelloController" />
```

<br><br>

#### 04. Collection타입 의존성
* List, Set, Map, props
* 의존성 설정 태그

| 태그 | 타입 |
|:---:|:---:|
| \<list> | java.util.List 또는 배열 |
| \<set> | java.util.Set |
| \<map> | java.util.Map |
| \<props> | java.util.Properties |

<br>
  
* list

```xml
<property name="lists">
  <list>
    <value>1</value>
    <ref bean="personBean" />
    <bean class="패키지명.Person">
      <property name="name" value="HyunJeong"/>
      <property name="age" value="12"/>
    </bean>
  </list>
</property>
```

<br>
  
* set

```xml
<property name="sets">
  <set>
    <value>2</value>
    <ref bean="personBean" />
    <bean class="패키지명.Person">
      <property name="name" value="HyunJeong"/>
      <property name="age" value="12"/>
    </bean>
  </set>
</property>
```

<br>
  
* map

```xml
<property name="maps">
  <map>
    <entry key="key1" value="3"/>
    <entry key="key2" value-ref="personBean"/>
    <entry key="key3">
      <bean class="패키지명.Person">
        <property name="name" value="HyunSoo"/>
        <property name="age" value="8"/>
      </bean>
    </entry>
  </map>
</property>
```

<br>
  
* props

```xml
<property name="props">
  <props>
    <prop key="webmaster">webmaster@naver.com</prop>
    <prop key="support">support@naver.com</prop>
  </props>
</property>
```

* 사용하기

```java
// 1. xml 파일 불러오기
ApplicationContext context = new GenericXmlApplicationContext("application-config.xml");
// 2. bean태그로 선언한 객체 
Customer cust = context.getBean(Customer.class);
```

<br><br>

#### 05. Prototype과 Singleton
* 싱글톤 패턴이란?
  - 생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나이고 최초 생성 이후에 호출된 생성자는 최초의 생성자가 생성한 객체를 리턴한다. 
  - 주로 공통된 객체를 여러개 생성해서 사용하는 DBCP(DataBase Connection Pool)와 같은 상황에서 많이 사용된다.


* 스프링 컨테이너는 Bean 생성 시, 컨테이너에 클래스 당 한 개의 인스턴스만 생성한다.
* 클래스에 Singleton패턴을 적용하지 않아도 항상 한 개의 인스턴스만 생성
* Spring의 Singleton패턴은 자바의 클래스에 Singleton패턴을 적용하여 구현하지 않는다.
* Spring에서는 `싱클톤 레지스트리`를 이용하여 일반 클래스도 싱글톤처럼 관리해주는 방식 제공.
* bean태그의 scope 속성으로 bean이 싱글톤으로 생성되게 할지 아니면 요청할때마다 생성되게 할지 설정할 수 있다.
* scope 속성 값

| scope 속성 값 | 설명 |
|:---:|:---|
| singleton | 컨테이너에 한 개의 인스턴스만 생성. (기본값) |
| prototype | 빈을 요청할 때마다 인스턴스 생성. |
| thread | 스레드별 생성. 현재 실행중인 스레드에 종속. 스레드가 죽으면 bean도 소멸 |
| request | HTTP 요쳥마다 빈 객체 생성. WebApplicationContext에서만 적용 |
| session | HTTP 세션마다 빈 객체 생성. WebApplicationContext에서만 적용 |
| application | Singleton 과 유사. java.servlet.ServletContext에도 등록됨. |
| globalSession | 글로벌 HTTP세션에 대한 bean 객체 생성. Portlet을 지원하는 컨텍스트에만 적용 가능<br>글로벌 세션이 없으면 Session 과 기능이 같다. |


* 예제

```java
ApplicationContext context = new GenericXmlApllication("application-config.xml");
Person person1 = context.getBean(Person.class);
Person person2 = context.getBean(Person.class);
System.out.println(person1 == person2);
```

* scope에 `prototype`로 설정하고, 두개의 클래스를 이름을 다르게 해서 선언한 후 == 비교시 `false`가 출력된다.
  - prototype으로 설정할 때에는 bean을 요청한 클라이언트마다 자신의 상태 값을 가져야 할 때이다.
* scope에 `singleton`로 설정하고, 두개의 클래스를 이름을 다르게 해서 선언한 후 == 비교시 `true`가 출력된다. 

<br><br><br>

### 1-2-2. Annotation을 이용한 생성자 주입
#### 00. 설정하기
* `<context:component-scan>`태그로 설정가능
* bean으로 등록될 클래스들이 있는 패키지를 지정.
* 상위 패키지 지정 시 하위 패키지까지 bean으로 등록될 클래스로 
* Namespace이용하면 자동추가됨.

```xml
<context:componetn-scan base-package="패키지명"/>
```

* 설정 후, 패키지 내의 각각의 클래스에 어노테이션을 설정

<br><br>

#### 01. Bean 설정
* Class명 위에 붙인다.
1. @Component
  - 일반적인 컴포넌트로 등록되기 위한 클래스에 사용.
2. @Controller
  - 컨트롤러 클래스에 사용
3. @Service
  - 서비스 클래스에 사용
4. @Repository
  - DAO클래스 또는 Repository클래스에 사용

<br><br>

#### 02. @Autowired를 이용한 의존성 주입
* `@Autowired`는 Annotation Type을 기준으로 의존성 주입.
* 맴버객체 위에 붙이기
* 변수이름과 같은 클래스가 주입된다.

```java
@Autowired
IHelloService helloService; // HelloService주입
```

<br><br>

#### 03. @Qualifier를 이용한 의존객체 설정.
* 전달하고 싶은 객체를 설정할 수 있다.
* IHelloService라는 인터페이스에 HelloService가 아닌 NiceService라는 객체를 주입하고 싶은 경우
* NiceService @Service에 ("이름지정") 안했을 경우 자동으로 `niceService`라는 이름이 부여됨.
  - `niceService` : 앞글자 소문자로 바뀐 클래스 이름

```java
@Autowired
@Qualifier("niceService")
IHelloService helloService;
```

<br><br>

#### 04. @Resource를 이용한 의존객체 설정.
* @Autowired와 @Qualifier를 같이 사용하는 것과 같다.
* name 속성을 이용하여 bean의 이름을 직접 지정할 수 있다.
* Java 9 버전 사용한다면 사용불가.

```java
@Resource(name="niceService")
IHelloService helloService;
```

<br><br>

#### 05. @Inject를 이용한 의존성 주입
* @Autowired를 사용하는 것과 같다.
* 같은 타입의 bean이 두개 이상 있을 경우 변수의 이름과 같은 이름을 갖는 bean을 찾는다.
* 존재하지 않을 경우 에러발생 : BeanCreationException, NoSuchBeanDefinitionException)
* 

```java
@Inject
IHelloService helloService;
```

<br><br><br>

### 1-2-3. Xml과 Annotation 비교
#### 01. Bean생성
* XML
  - `<bean id="bean이름" class="패키지.클래스명"/>

* Annotation
  - 설정파일에 `<context:component-scan base-package="패키지명"/>` 추가
  - 자바 클래스 위에 @Controller, @Component, @Service, @Repository 중 하나 선언
  - bean의 이름은 클래스 이름에서 첫 문자만 소문자로 바뀐 이름으로 자동 지정

<br>

#### 02. 의존성 주입
* XML
  - 생성자
    + 자바 클래스에 생성자 추가
    + `<constructor-arg name="변수명" ref="bean이름" />`
  - Setter메소드
    + 자바 클래스에 메소드 추가
    + `<property name="변수명" ref="bean이름" />`

* Annotation
  - 생성자
    + 자바 클래스 필드, 생성자, Setter메소드 위에 `@Autowired` 또는 `@Inject` 중 하나 선언
  - Setter
    + 인터페이스를 구현한 클래스가 두 개 이상이면 `@Autowired`아래에 `@Qualifier("빈이름")`추가로 선언
    + `@Resource(name="빈이름")`으로 선언도 가능하지만 Java 9버전 사용불가 









<br><br><br><br>
